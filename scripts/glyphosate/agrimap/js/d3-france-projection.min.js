// d3-france-projection Version 1.0.0. Copyright 2017 LeMonde.
(function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports, require("d3")) : "function" == typeof define && define.amd ? define(["exports", "d3"], t) : t(e.geoFranceProjection = e.geoFranceProjection || {}, d3)
}
)(this, function(e, t) {
    "use strict";
    function n(e, t) {
        e < a && (a = e),
        e > i && (i = e),
        t < c && (c = t),
        t > l && (l = t)
    }
    function r(e, n, r) {
        var o = n[1][0] - n[0][0]
          , a = n[1][1] - n[0][1]
          , c = e.clipExtent && e.clipExtent();
        e.scale(150).translate([0, 0]),
        null != c && e.clipExtent(null),
        t.geoStream(r, e.stream(u));
        var i = u.result()
          , l = Math.min(o / (i[1][0] - i[0][0]), a / (i[1][1] - i[0][1]))
          , s = +n[0][0] + (o - l * (i[1][0] + i[0][0]) / 2)
          , f = +n[0][1] + (a - l * (i[1][1] + i[0][1]) / 2);
        return null != c && e.clipExtent(c),
        e.scale(150 * l).translate([s, f])
    }
    function o(e, t, n) {
        return r(e, [[0, 0], t], n)
    }
    var a = 1 / 0
      , c = a
      , i = -a
      , l = i
      , s = function() {}
      , u = {
        point: n,
        lineStart: s,
        lineEnd: s,
        polygonStart: s,
        polygonEnd: s,
        result: function() {
            var e = [[a, c], [i, l]];
            return a = 1 / 0,
            c = a,
            i = -a,
            l = i,
            e
        }
    }
      , f = (new Map).set("france", {
        rotate: [-6.5, .1],
        center: [-3.6, 45.2],
        parallels: [0, 60],
        scale: 1,
        translate: [0, 0],
        bbox: [[-6.5, 51], [10, 41]]
    }).set("guadeloupe", {
        center: [-61.41, 16.17],
        scale: 1,
        translate: [-.0725, .06125],
        bbox: [[-61.85, 16.55], [-60.97, 15.8]]
    }).set("martinique", {
        center: [-61.03, 14.67],
        scale: 1,
        translate: [-.05825, .06],
        bbox: [[-61.2968, 14.943], [-60.715, 14.321]]
    }).set("guyane", {
        center: [-53.2, 3.9],
        scale: .2,
        translate: [-.0455, .06025],
        bbox: [[-54.5, 6.29], [-50.9, 1.48]]
    }).set("la-reunion", {
        center: [55.52, -21.13],
        scale: 1,
        translate: [-.031, .06025],
        bbox: [[55.0088, -20.7228], [56.063449, -21.621723]]
    }).set("mayotte", {
        center: [45.16, -12.8],
        scale: 1,
        translate: [-.0185, .059],
        bbox: [[44.9153, -12.594], [45.3602, -13.069]]
    }).set("saint-pierre-et-miquelon", {
        center: [-56.23, 46.93],
        scale: 1,
        translate: [-.0085, .061],
        bbox: [[-56.517, 47.1969], [-56.0928, 46.7103]]
    }).set("saint-barthelemy", {
        center: [-62.82, 17.92],
        scale: 2,
        translate: [.0045, .0635],
        bbox: [[-62.92, 17.98], [-62.73, 17.82]]
    }).set("saint-martin", {
        center: [-63.08, 18.09],
        scale: 2,
        translate: [-.0015, .0575],
        bbox: [[-63.21, 18.17], [-62.96, 18.01]]
    }).set("futuna", {
        center: [-178.1, -14.3],
        scale: 2,
        translate: [.0125, .0635],
        bbox: [[-178.2177, -14.2114], [-177.983, -14.3924]]
    }).set("wallis", {
        center: [-176.2, -13.3],
        scale: 2,
        translate: [.0183, .0575],
        bbox: [[-176.4, -13.1], [-176, -13.5]]
    }).set("moorea-tahiti", {
        center: [-149.55, -17.67],
        scale: 1,
        translate: [.03125, .06],
        bbox: [[-150, -17.41], [-149.11, -17.93]]
    }).set("nouvelle-caledonie", {
        center: [165.8, -21.07],
        scale: .2,
        translate: [.0475, .06],
        bbox: [[163.1444, -19.3385], [168.286, -23.278]]
    })
      , p = function() {
        function e(e) {
            return l = null,
            Array.from(f).find(function(t) {
                return t[1].points.point(e[0], e[1])
            }),
            l
        }
        function n() {
            return c = null,
            i = null,
            e
        }
        var a = arguments
          , c = void 0
          , i = void 0
          , l = void 0;
        return f.forEach(function(e, n) {
            e.projection || (e.rotate && e.parallels ? f.get(n).projection = t.geoConicConformal().center(e.center).rotate(e.rotate).parallels(e.parallels) : e.center && (f.get(n).projection = t.geoMercator().center(e.center)))
        }),
        e.invert = function(e) {
            var t = f.get("france").projection.scale()
              , n = f.get("france").projection.translate()
              , r = (e[0] - n[0]) / t
              , o = (e[1] - n[1]) / t
              , a = Array.from(f).find(function(e, a) {
                if (0 === a)
                    return !1;
                var c = e[1].projection(e[1].bbox[0])
                  , i = e[1].projection(e[1].bbox[1])
                  , l = (c[0] - n[0]) / t
                  , s = (c[1] - n[1]) / t
                  , u = (i[0] - n[0]) / t
                  , f = (i[1] - n[1]) / t;
                return r >= l && r < u && o >= s && o < f
            });
            return (a ? a[1].projection : f.get("france").projection).invert(e)
        }
        ,
        e.stream = function(e) {
            if (c && i === e)
                return c;
            var t = Array.from(f).map(function(t) {
                return t[1].projection.stream(e)
            });
            return i = e,
            c = {
                point: function(e, n) {
                    t.forEach(function(t) {
                        return t.point(e, n)
                    })
                },
                sphere: function() {
                    t.forEach(function(e) {
                        return e.sphere()
                    })
                },
                lineStart: function() {
                    t.forEach(function(e) {
                        return e.lineStart()
                    })
                },
                lineEnd: function() {
                    t.forEach(function(e) {
                        return e.lineEnd()
                    })
                },
                polygonStart: function() {
                    t.forEach(function(e) {
                        return e.polygonStart()
                    })
                },
                polygonEnd: function() {
                    t.forEach(function(e) {
                        return e.polygonEnd()
                    })
                }
            }
        }
        ,
        e.precision = function(e) {
            return a.length ? (f.forEach(function(t) {
                return t.projection.precision(e)
            }),
            n()) : f.get("france").precision()
        }
        ,
        e.scale = function(t) {
            return arguments.length ? (f.forEach(function(e) {
                return e.projection.scale(t * e.scale)
            }),
            e.translate(f.get("france").projection.translate())) : f.get("france").projection.scale()
        }
        ,
        e.translate = function(e) {
            if (!arguments.length)
                return f.get("france").projection.translate();
            var t = f.get("france").projection.scale();
            return f.forEach(function(n, r) {
                var o = [e[0] + n.translate[0] * t, e[1] + n.translate[1] * t]
                  , a = n.projection.translate(o)(n.bbox[0])
                  , c = n.projection.translate(o)(n.bbox[1]);
                f.get(r).points = n.projection.translate(o).clipExtent([a, c]).stream({
                    point: function(e, t) {
                        l = [e, t]
                    }
                })
            }),
            n()
        }
        ,
        e.fitExtent = function(t, n) {
            return r(e, t, n)
        }
        ,
        e.fitSize = function(t, n) {
            return o(e, t, n)
        }
        ,
        e.scale(2500)
    };
    window.geoFranceProjection = p,
    Object.defineProperty(e, "__esModule", {
        value: !0
    })
});
